mem = [3,8,1001,8,10,8,105,1,0,0,21,34,43,64,85,98,179,260,341,422,99999,3,9,1001,9,3,9,102,3,9,9,4,9,99,3,9,102,5,9,9,4,9,99,3,9,1001,9,2,9,1002,9,4,9,1001,9,3,9,1002,9,4,9,4,9,99,3,9,1001,9,3,9,102,3,9,9,101,4,9,9,102,3,9,9,4,9,99,3,9,101,2,9,9,1002,9,3,9,4,9,99,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,2,9,4,9,99,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,99,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,101,1,9,9,4,9,99,3,9,101,1,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,99,3,9,101,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,99]
#mem = [3,15,3,16,1002,16,10,16,1,16,15,15,4,15,99,0,0]

def run(mem, inputs = [])
  mem = mem.dup
  pc = 0

  loop do
    opcode, o1, o2, o3 = mem[pc, 4]

    #puts "Running #{opcode}"

    op = opcode % 100
    modes = (opcode / 100).digits

    v1 = modes[0] == 1 ? o1 : mem[o1] if [1, 2, 5, 6, 7, 8].include?(op)
    v2 = modes[1] == 1 ? o2 : mem[o2] if [1, 2, 5, 6, 7, 8].include?(op)

    if op == 1     # addition
      mem[o3] = v1 + v2
      pc += 4
    elsif op == 2  # multiply
      mem[o3] = v1 * v2
      pc += 4
    elsif op == 3  # get input
      if input = inputs.shift
        puts "TAKING INPUT #{input}"
        mem[o1] = input
      else
        puts "ENTER INPUT:"
        mem[o1] = STDIN.gets.to_i
      end
      pc += 2
    elsif op == 4  # print output
      puts "OUT: #{mem[o1]}"
      return mem[o1]
      pc += 2
    elsif op == 5  # jump-if-true
      pc = v1 != 0 ? v2 : pc + 3
    elsif op == 6  # jump-if-false
      pc = v1 == 0 ? v2 : pc + 3
    elsif op == 7  # less than
      mem[o3] = v1 < v2 ? 1 : 0
      pc += 4
    elsif op == 8  # equals
      mem[o3] = v1 == v2 ? 1 : 0
      pc += 4
    elsif op == 99
      break
    else
      raise "Unsupported opcode #{op}"
    end
  end
end

results = []

(0..4).to_a.permutation.each do |ss|
  p ss
  inp = 0

  ss.each do |s|
    inp = run(mem, [s, inp])
  end

  puts inp
  results << inp
end

p results
p results.max